<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="description" content="An interactive hill chart with draggable tasks." />
        <title>Hill Chart</title>
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"
            integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"
        />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"></script>
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            .task {
                cursor: pointer;
                font-size: 12px;
            }

            .task-label {
                fill: black;
                font-size: 12px;
            }

            .task-point {
                cursor: grab;
            }

            .hill-path {
                stroke: gray;
                stroke-width: 2;
                fill: none;
            }
        </style>
    </head>

    <body class="font-sans m-2 bg-gray-100 min-h-screen flex flex-col items-center print:bg-transparent">
        <!-- Navbar -->
        <nav class="w-full p-4 flex flex-col md:flex-row print:flex-row justify-between items-center">
            <input
                id="chartTitle"
                class="bg-transparent focus:outline-none text-2xl md:text-3xl font-bold mb-4 md:mb-0 text-center md:text-left"
                type="text"
                placeholder="Hill Chart"
            />
            <div class="flex space-x-2">
                <!-- Print button -->
                <button id="print" class="py-1 px-2 rounded hover:text-blue-600 print:hidden">
                    <i class="fa-solid fa-print"></i>
                    Print Page
                </button>
                <!-- Export PNG button -->
                <button id="exportPNG" class="py-1 px-2 rounded hover:text-blue-600 print:hidden">
                    <i class="fa-solid fa-file-arrow-down"></i>
                    Export PNG
                </button>
                <!-- Clear tasks button -->
                <button id="deleteAll" class="py-1 px-2 rounded hover:text-red-600 print:hidden">
                    <i class="fa-solid fa-circle-exclamation"></i>
                    Reset Chart
                </button>
            </div>
        </nav>

        <svg
            id="chart"
            width="800"
            height="400"
            class="bg-white shadow-md rounded-lg print:shadow-none print:bg-transparent"
            role="img"
            aria-labelledby="chart-title chart-desc"
        >
            <title id="chart-title">Hill Chart</title>
            <desc id="chart-desc">A dynamic hill chart with draggable tasks</desc>
        </svg>

        <section
            class="tasks-container mt-10 bg-white p-6 rounded-lg shadow-md w-full max-w-2xl print:shadow-none print:bg-transparent"
            aria-labelledby="tasks-title"
        >
            <ul id="taskList" class="space-y-2">
                <!-- Dynamic task items will be inserted here -->
            </ul>
        </section>
        <button id="addTask" class="py-1 px-8 mt-4 bg-green-500 text-white rounded hover:bg-green-600 print:hidden">
            <i class="fa-regular fa-square-plus"></i>
        </button>

        <script>
            // Constants
            const width = 800,
                height = 400,
                xMin = 50,
                xMax = 750;
            const hillFn = (x) => 150 * Math.sin((Math.PI * (x + 200)) / 400) + 200;
            const colorPalette = ["#3498db", "#e74c3c", "#2ecc71", "#9b59b6", "#f1c40f"];

            const chartTitleElement = document.getElementById("chartTitle");

            const svg = d3.select("#chart").attr("width", width).attr("height", height);
            let demoTasks = [
                { id: 1, label: "Task 1", x: 150, color: "#1f77b4", completed: false },
                { id: 2, label: "Task 2", x: 350, color: "#ff7f0e", completed: false },
                { id: 3, label: "Task 3", x: 600, color: "#2ca02c", completed: false },
            ].map((d) => ({ ...d, y: hillFn(d.x) }));
            let tasks = [...demoTasks];

            let selectedTask = null;
            let completedTasksPoint;
            const maxTaskTextLength = 64;

            // Initialize the hill chart
            function initHillChart() {
                const hillPoints = d3.range(xMin, xMax).map((x) => ({ x, y: hillFn(x) }));

                svg.append("path")
                    .datum(hillPoints)
                    .attr("class", "hill-path")
                    .attr(
                        "d",
                        d3
                            .line()
                            .curve(d3.curveBasis)
                            .x((d) => d.x)
                            .y((d) => d.y),
                    );

                svg.append("line")
                    .attr("x1", 400)
                    .attr("x2", 400)
                    .attr("y1", 100)
                    .attr("y2", 350)
                    .attr("stroke", "gray")
                    .attr("stroke-dasharray", "5,5");

                const labels = [
                    { x: 200, text: "FIGURING THINGS OUT" },
                    { x: 600, text: "MAKING IT HAPPEN" },
                ];

                labels.forEach(({ x, text }) => {
                    svg.append("text")
                        .attr("x", x)
                        .attr("y", 350)
                        .attr("text-anchor", "middle")
                        .attr("font-size", 12)
                        .text(text);
                });
            }

            // Function to load tasks from localStorage
            function loadTasks() {
                const tasksJson = localStorage.getItem("tasks");
                if (tasksJson) {
                    tasks = JSON.parse(tasksJson).map((d) => ({ ...d, y: hillFn(d.x) }));
                }
            }

            // Function to save tasks to localStorage
            function saveTasks() {
                localStorage.setItem("tasks", JSON.stringify(tasks));
                renderTaskList();
            }

            function resetPage() {
                if (
                    confirm("Are you sure you want to delete ALL tasks on this page?\n\nThis action cannot be undone.")
                ) {
                    localStorage.removeItem("chartTitle");
                    localStorage.removeItem("tasks");
                    location.reload();
                }
            }

            function loadChartTitle() {
                const title = localStorage.getItem("chartTitle");
                chartTitleElement.value = title;
            }

            function updateChartTitle() {
                const chartTitle = chartTitleElement.value;
                localStorage.setItem("chartTitle", chartTitle);
            }

            function removeChartTitle() {
                chartTitleElement.value = "";
                updateChartTitle();
                loadChartTitle();
            }

            // Render all task points on the chart
            function renderTasksOnChart() {
                const taskPoints = svg.selectAll(".task").data(
                    tasks.filter((d) => !d.completed),
                    (d) => d.id,
                );

                const taskGroup = taskPoints
                    .enter()
                    .append("g")
                    .attr("class", "task")
                    .attr("transform", (d) => `translate(${d.x},${d.y})`)
                    .style("cursor", "grab")
                    .call(d3.drag().on("start", dragStarted).on("drag", dragged).on("end", dragEnded));

                taskGroup
                    .append("circle")
                    .attr("r", 10)
                    .attr("class", "task-point")
                    .attr("fill", (d) => d.color);

                taskGroup
                    .append("text")
                    .attr("class", "task-label")
                    .attr("x", 15)
                    .attr("y", 5)
                    .text((d) => (d.label.length > 12 ? d.label.slice(0, 12) + "..." : d.label));

                taskPoints.exit().remove();
            }

            // Render task list in the DOM
            function renderTaskList() {
                const taskList = document.getElementById("taskList");
                taskList.innerHTML = ""; // Clear existing tasks

                // Sort tasks to place completed tasks at the bottom
                const sortedTasks = tasks.slice().sort((a, b) => {
                    if (a.completed === b.completed) {
                        return a.x - b.x;
                    }
                    return a.completed - b.completed;
                });

                sortedTasks.forEach((task) => {
                    const taskItem = createTaskListItem(task);
                    taskList.appendChild(taskItem);
                });

                renderCompletedTasksPoint();
            }

            // Create a single task list item
            function createTaskListItem(task) {
                const taskItem = document.createElement("li");
                taskItem.innerHTML = `
                    <div class="flex items-center justify-between px-2 hover:bg-gray-200 active:bg-gray-200}">
                        <div class="flex items-center flex-1">
                            <i class="task-status-icon hover:cursor-pointer fa-regular mr-2 ${task.completed ? "fa-check-square text-green-500" : "fa-square text-blue-500"}" data-task-id="${task.id}"></i>
                            <input class="task-label-input flex-1 bg-transparent focus:outline-none p-1 ${task.completed ? "line-through text-gray-300" : ""}" type="text" value="${task.label}" data-task-id="${task.id}" maxlength=${maxTaskTextLength} ${task.completed ? "disabled" : ""}/>
                        </div>
                        <label class="color-indicator bg-transparent text-xl ${task.completed ? "hidden" : "block"} " style="color: ${task.color};">
                          <input class="task-color-input hidden" type="color" value="${task.color}" data-task-id="${task.id}" ${task.completed ? "disabled" : ""}/>
                          <i class="fa-solid fa-circle"></i>
                        </label>
                        <button class="removeTask p-2 ml-2 text-red-300 hover:text-red-500 print:hidden">
                            <i class="fa-solid fa-trash"></i>
                        </button>
                    </div>
                `;

                addTaskItemEventListeners(taskItem, task);
                return taskItem;
            }

            // Add event listeners to a task list item
            function addTaskItemEventListeners(taskItem, task) {
                taskItem.querySelector(".task-label-input").addEventListener("change", (event) => {
                    task.label = event.target.value;
                    saveTasks();
                    updateTaskDisplay(task);
                });

                taskItem.querySelector(".task-color-input").addEventListener("input", (event) => {
                    task.color = event.target.value;
                    saveTasks();
                    updateTaskDisplay(task);
                });

                taskItem.querySelector(".task-status-icon").addEventListener("click", () => {
                    toggleTaskCompletion(task.id);
                    saveTasks();
                    renderTaskList();
                });

                taskItem.querySelector(".removeTask").addEventListener("click", () => {
                    removeTask(task.id);
                    saveTasks();
                    renderTaskList();
                });
            }

            // Update the task display on the chart
            function updateTaskDisplay(task) {
                const taskElement = svg.selectAll(".task").filter((d) => d.id === task.id);
                taskElement.select("text").text((d) => d.label);
                taskElement.select("circle").attr("fill", (d) => d.color);
            }

            // Handle task dragging
            function dragStarted(event, d) {
                d3.select(this).select("circle").attr("cursor", "grabbing");
            }

            function dragged(event, d) {
                d.x = Math.max(xMin, Math.min(xMax, event.x));
                d.y = hillFn(d.x);
                d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
            }

            function dragEnded(event, d) {
                d3.select(this).select("circle").attr("cursor", "grab");
                // If task is dragged to the end (+/- 5), mark it as completed
                if (d.x >= xMax - 5) {
                    d.x = xMax - 20;
                    d.y = hillFn(d.x);
                    toggleTaskCompletion(d.id);
                }
                saveTasks();
            }

            // Toggle task completion
            function toggleTaskCompletion(taskId) {
                const task = tasks.find((t) => t.id === taskId);
                task.completed = !task.completed;
                saveTasks();
                if (task.completed) {
                    svg.selectAll(".task")
                        .filter((d) => d.id === taskId)
                        .remove();
                } else {
                    renderTasksOnChart();
                }
            }

            // Remove a task
            function removeTask(taskId) {
                tasks = tasks.filter((t) => t.id !== taskId);
                saveTasks();
                svg.selectAll(".task")
                    .filter((d) => d.id === taskId)
                    .remove();
            }

            // Render completed tasks point
            function renderCompletedTasksPoint() {
                const completedCount = tasks.filter((task) => task.completed).length;
                if (completedTasksPoint) {
                    completedTasksPoint.remove();
                }

                if (completedCount === 0) {
                    return;
                }

                completedTasksPoint = svg.append("g").attr("transform", `translate(${xMax}, ${hillFn(xMax)})`);

                completedTasksPoint.append("circle").attr("r", 15).attr("fill", "#c2c2c2");

                completedTasksPoint
                    .append("text")
                    .attr("class", "task-label")
                    .attr("x", 0)
                    .attr("y", 5)
                    .attr("text-anchor", "middle")
                    .attr("font-weight", "bold")
                    .text(completedCount);
            }

            // Add a new task
            function addNewTask() {
                const newId = tasks.length ? Math.max(...tasks.map((t) => t.id)) + 1 : 1;
                const newTask = {
                    id: newId,
                    label: `Task ${newId}`,
                    x: xMin,
                    color: colorPalette[(newId - 1) % colorPalette.length],
                    y: hillFn(xMin),
                    completed: false,
                };
                tasks.push(newTask);
                saveTasks();
                renderTasksOnChart();
                renderTaskList();
            }

            // Export chart as PNG
            function exportChartAsPNG() {
                const svgNode = document.getElementById("chart");
                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(svgNode);
                const image = new Image();

                // Include styles for correct rendering
                const style = `
                    <style>
                        .hill-path {
                            fill: none; /* No fill */
                            stroke: black; /* Stroke color */
                            stroke-width: 2; /* Stroke width */
                        }
                        text {
                            font-family: sans-serif;
                            font-size: 12px;
                        }
                    </style>
                `;

                // Insert styles directly into the SVG source
                const svgWithStyles = svgString.replace(/<\/svg>/, `${style}</svg>`);

                image.src = "data:image/svg+xml;base64," + window.btoa(unescape(encodeURIComponent(svgWithStyles)));
                image.onload = function () {
                    const canvas = document.createElement("canvas");
                    const scaleFactor = 4;
                    canvas.width = svgNode.clientWidth * scaleFactor;
                    canvas.height = svgNode.clientHeight * scaleFactor;

                    const context = canvas.getContext("2d");
                    context.fillStyle = "white";
                    context.fillRect(0, 0, canvas.width, canvas.height);
                    context.imageSmoothingEnabled = true; // Enable image smoothing
                    context.setTransform(scaleFactor, 0, 0, scaleFactor, 0, 0); // Use setTransform for scaling
                    context.drawImage(image, 0, 0);

                    const png = canvas.toDataURL("image/png");
                    const a = document.createElement("a");
                    a.href = png;
                    a.download = "hillchart.png";
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                };
            }

            // Event Listeners
            document.getElementById("addTask").addEventListener("click", addNewTask);
            document.getElementById("exportPNG").addEventListener("click", exportChartAsPNG);
            document.getElementById("deleteAll").addEventListener("click", resetPage);
            document.getElementById("print").addEventListener("click", () => {
                renderTasksOnChart();
                renderTaskList();
                window.print();
            });

            chartTitleElement.addEventListener("input", () => {
                updateChartTitle();
                loadChartTitle();
            });

            // Initial rendering
            initHillChart();

            // Load tasks when the page loads
            document.addEventListener("DOMContentLoaded", () => {
                loadTasks();
                renderTasksOnChart();
                loadChartTitle();
                renderTaskList();
            });
        </script>
    </body>
</html>
